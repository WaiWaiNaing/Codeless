/**
 * Codeless v4 – Code generation (AST → server.js + types.d.ts)
 * No new Function, no vm2: emit static JS.
 */

/**
 * @param {import('./parser.js').AST} ast
 * @param {{ adapter: 'sqlite'|'postgres', serverPath: string, runtimeDir: string }} options
 * @returns {{ server: string, types: string }}
 */
export function generate(ast, options = {}) {
  const { adapter = 'sqlite', serverPath = './generated/server.js', runtimeDir = './runtime' } = options;
  const relRuntime = runtimeDir.startsWith('.') ? runtimeDir : `./${runtimeDir}`;

  const knownTables = new Set(ast.dataBlocks.map((b) => b.name));
  const validatorSchemas = ast.dataBlocks.map((b) => ({ name: b.name, fields: b.fields }));
  const actionMap = new Map(ast.doBlocks.map((d) => [d.name, d]));

  const adapterImport = adapter === 'postgres' ? 'PostgresAdapter' : 'SqliteAdapter';
  const adapterPath = `${relRuntime}/adapters/${adapter}.js`;

  let server = `/**
 * Generated by Codeless v4 – do not edit by hand.
 * Edit api.cls and run: codeless build
 */

import express from 'express';
import { createValidator } from '${relRuntime}/core/validator.js';
import { authMiddleware } from '${relRuntime}/core/auth.js';
import { createSugar } from '${relRuntime}/core/sugar.js';
import { ${adapterImport} } from '${adapterPath}';

const app = express();
app.use(express.json());

`;

  server += `// Database adapter\n`;
  if (adapter === 'sqlite') {
    server += `const db = new SqliteAdapter(process.env.DB_FILE || 'codeless.db');\n`;
  } else {
    server += `const db = new PostgresAdapter(process.env.DATABASE_URL);\n`;
  }
  server += `await db.connect();\n`;
  server += `const knownTables = new Set(${JSON.stringify([...knownTables])});\n`;
  server += `const sugar = createSugar(db, knownTables);\n\n`;

  for (const schema of validatorSchemas) {
    const validatorDef = schemaToValidatorDef(schema);
    server += `const validator_${schema.name} = createValidator("${schema.name}", ${JSON.stringify(validatorDef)});\n`;
  }
  server += '\n';

  for (const block of ast.doBlocks) {
    server += `async function ${block.name}(data) {\n`;
    server += `  ${block.body.split('\n').join('\n  ')}\n`;
    server += `}\n\n`;
  }

  server += `app.get('/__health', (req, res) => res.json({ status: 'ok', engine: 'Codeless v4' }));\n\n`;
  server += `// Routes\n`;
  for (const route of ast.routeLines) {
    const method = route.method.toLowerCase();
    const middlewares = [];
    let actionName = null;
    for (const step of route.pipeline) {
      if (step.kind === 'auth') middlewares.push('authMiddleware');
      else if (step.kind === 'validate') middlewares.push(`validator_${step.schema}.middleware()`);
      else if (step.kind === 'action') actionName = step.name;
    }
    if (!actionName) continue;
    const mw = middlewares.length ? middlewares.join(', ') + ', ' : '';
    server += `app.${method}("${route.path}", ${mw}async (req, res) => {\n`;
    server += `  try {\n`;
    server += `    const ctx = { ...req.query, ...req.params, ...(req.validated ?? req.body ?? {}) };\n`;
    server += `    const result = await ${actionName}(ctx);\n`;
    server += `    res.json(result ?? { success: true });\n`;
    server += `  } catch (err) {\n`;
    server += `    const status = err.status ?? 500;\n`;
    server += `    res.status(status).json({ error: err.message });\n`;
    server += `  }\n`;
    server += `});\n\n`;
  }

  server += `const port = parseInt(process.env.PORT || '3000', 10);\n`;
  server += `app.listen(port, () => console.log('Codeless v4 server on port', port));\n`;

  let types = `/**
 * Generated by Codeless v4 – do not edit by hand.
 */

`;
  for (const block of ast.dataBlocks) {
    types += `export interface ${block.name} {\n  id: number;\n`;
    for (const f of block.fields) {
      const t = fieldToTsType(f);
      types += `  ${f.name}${f.optional ? '?' : ''}: ${t};\n`;
    }
    types += `}\n\n`;
  }

  return { server, types };
}

function schemaToValidatorDef(schema) {
  const def = {};
  for (const f of schema.fields) {
    def[f.name] = {
      type: f.type.toLowerCase(),
      required: !f.optional,
      ...(f.args?.min !== undefined && { min: f.args.min }),
      ...(f.args?.max !== undefined && { max: f.args.max }),
      ...(f.args?.enum && { enum: f.args.enum }),
    };
  }
  return def;
}

function fieldToTsType(f) {
  if (f.type === 'Number') return 'number';
  if (f.type === 'Boolean') return 'boolean';
  if (f.type === 'String' || f.type === 'Enum' || f.type === 'Password') return 'string';
  if (f.type === 'Date') return 'string';
  return 'unknown';
}
