/**
 * Codeless v4 – AOT-Optimized Code Generation
 * Lean and modular: uses aot-validation, QueryBuilder, wrapAction, shared defaults.
 */

import { schemaToValidationCode, fieldToTsType } from './aot-validation.js';
import { DEFAULTS } from '../shared/defaults.js';

export function generate(ast, options = {}) {
  const { adapter = 'sqlite', serverPath = './generated/server.js', runtimeDir = './runtime' } = options;
  const relRuntime = runtimeDir.startsWith('.') ? runtimeDir : `./${runtimeDir}`;

  const knownTables = new Set(ast.dataBlocks.map((b) => b.name));

  const adapterImport = adapter === 'postgres' ? 'PostgresAdapter' : 'SqliteAdapter';
  const adapterPath = `${relRuntime}/adapters/${adapter}.js`;

  let server = `/**
 * Generated by Codeless v4 – AOT Optimized Server (Lean & Modular)
 */

import express from 'express';
import jwt from 'jsonwebtoken';
import { signToken } from '${relRuntime}/auth.js';
import { wrapAction } from '${relRuntime}/wrapAction.js';
import { toCodelessError } from '${relRuntime}/errors.js';
import QueryBuilder from '${relRuntime}/queryBuilder.js';
import { ${adapterImport} } from '${adapterPath}';

const app = express();
app.use(express.json());

const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET && process.env.NODE_ENV === 'production') {
  console.error('FATAL: JWT_SECRET environment variable is required in production.');
  process.exit(1);
}
const SECRET_KEY = JWT_SECRET || '${DEFAULTS.JWT_SECRET}';

// Database adapter connection
`;
  if (adapter === 'sqlite') {
    server += `const db = new SqliteAdapter(process.env.DB_FILE || '${DEFAULTS.DB_FILE}');\n`;
  } else {
    server += `const db = new PostgresAdapter(process.env.DATABASE_URL);\n`;
  }
  server += `await db.connect();\n\n`;

  // Pre-compiled SQL via QueryBuilder (single place for SQL logic)
  const tableCols = {};
  for (const b of ast.dataBlocks) tableCols[b.name] = b.fields.map((f) => f.name);
  server += `const TABLE_COLS = ${JSON.stringify(tableCols)};\n`;
  server += `let PREP;\n`;
  server += `try {\n`;
  server += `  PREP = QueryBuilder.prepareAll('${adapter}', db, TABLE_COLS);\n`;
  server += `} catch (e) {\n`;
  server += `  console.error('FATAL: Failed to prepare SQL statements. Did you run migrations?', e.message);\n`;
  server += `  process.exit(1);\n`;
  server += `}\n\n`;
  server += `\n// AOT Database Helpers\nconst aot_db = {\n`;
  for (const b of ast.dataBlocks) {
    const t = b.name;
    const args = b.fields.map(f => `data.${f.name}`);
    const allowedCols = JSON.stringify(['id', ...b.fields.map(f => f.name)]);
    server += `  ${t}: {\n`;
    if (adapter === 'sqlite') {
      server += `    save: (data, _retry = 0) => {
      try {
        const r = PREP['${t}'].insert.run(${args.join(', ')});
        return { id: r.lastInsertRowid };
      } catch (e) {
        if ((e.code === 'SQLITE_BUSY' || e.code === 'SQLITE_LOCKED') && _retry < 3) {
          Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, 50 * (_retry + 1));
          return aot_db.${t}.save(data, _retry + 1);
        }
        throw e;
      }
    },\n`;
      server += `    update: (id, data) => PREP['${t}'].update.run(${args.join(', ')}, id),\n`;
      server += `    remove: (id) => PREP['${t}'].delete.run(id),\n`;
      server += `    find: (id) => PREP['${t}'].findById.get(id),\n`;
      server += `    findAll: async (where = {}, orderBy = null) => {
      const allowed = ${allowedCols};
      for (const k of Object.keys(where)) {
        if (!allowed.includes(k)) throw Object.assign(new Error('Invalid where column: ' + k), { status: 400 });
      }
      if (orderBy && !allowed.includes(orderBy.field)) throw Object.assign(new Error('Invalid orderBy column: ' + orderBy.field), { status: 400 });
      return db.findAll('${t}', where, orderBy);
    }\n`;
    } else {
      server += `    save: async (data) => { const r = await db.pool.query(PREP['${t}'].insert, [${args.join(', ')}]); return { id: r.rows[0].id }; },\n`;
      server += `    update: async (id, data) => await db.pool.query(PREP['${t}'].update, [${args.join(', ')}, id]),\n`;
      server += `    remove: async (id) => await db.pool.query(PREP['${t}'].delete, [id]),\n`;
      server += `    find: async (id) => { const r = await db.pool.query(PREP['${t}'].findById, [id]); return r.rows[0]; },\n`;
      server += `    findAll: async (where = {}, orderBy = null) => {
      const allowed = ${allowedCols};
      for (const k of Object.keys(where)) {
        if (!allowed.includes(k)) throw Object.assign(new Error('Invalid where column: ' + k), { status: 400 });
      }
      if (orderBy && !allowed.includes(orderBy.field)) throw Object.assign(new Error('Invalid orderBy column: ' + orderBy.field), { status: 400 });
      return db.findAll('${t}', where, orderBy);
    }\n`;
    }
    server += `  },\n`;
  }
  server += `  query: async (sql, ...params) => {
    const trimmed = (typeof sql === 'string' ? sql : '').trim();
    if (!trimmed.toUpperCase().startsWith('SELECT')) {
      throw Object.assign(new Error('sugar.query() is restricted to SELECT statements only.'), { status: 403 });
    }
    return db.query(sql, params);
  }\n};\n\n`;
  // 2. Static Validation Pre-calculation
  server += `// Static Validation Blocks\n`;
  for (const b of ast.dataBlocks) {
    server += schemaToValidationCode(b);
  }

  // 4. Response Serialization Optimization (Fast JSON)
  server += `\n// Fast-path JSON Stringifiers\n`;
  for (const b of ast.dataBlocks) {
    server += `function fastJson_${b.name}(data, _d) {\n`;
    server += `  const depth = _d ?? 0;\n`;
    server += `  if (depth > 10) return 'null';\n`;
    server += `  if (Array.isArray(data)) return '[' + data.map((x) => fastJson_${b.name}(x, depth + 1)).join(',') + ']';\n`;
    server += `  if (!data) return 'null';\n`;
    let parts = [`'"id":' + data.id`];
    for (const f of b.fields) {
      if (['string', 'password', 'date', 'enum'].includes(f.type.toLowerCase()) || f.args?.enum) {
        parts.push(`'"${f.name}":"' + (data.${f.name} || '').toString().replace(/(["\\\\\\n\\r\\t])/g, '\\\\$1') + '"'`);
      } else {
        parts.push(`'"${f.name}":' + (data.${f.name} !== undefined ? data.${f.name} : 'null')`);
      }
    }
    server += `  return '{' + ${parts.join(" + ',' + ")} + '}';\n`;
    server += `}\n\n`;
  }

  // Action Blocks (do blocks)
  for (const block of ast.doBlocks) {
    let body = block.body;
    // Replace sugar.xxx('Table'|"Table") with AOT db calls (single or double quotes)
    body = body.replace(/sugar\.save\(\s*['"]([^'"]+)['"]\s*,\s*(.*?)\)/g, "aot_db.$1.save($2)");
    body = body.replace(/sugar\.find\(\s*['"]([^'"]+)['"]\s*,\s*(.*?)\)/g, "aot_db.$1.find($2)");
    body = body.replace(/sugar\.remove\(\s*['"]([^'"]+)['"]\s*,\s*(.*?)\)/g, "aot_db.$1.remove($2)");
    body = body.replace(/sugar\.update\(\s*['"]([^'"]+)['"]\s*,\s*(.*?)\s*,\s*(.*?)\)/g, "aot_db.$1.update($2, $3)");
    body = body.replace(/sugar\.all\(\s*['"]([^'"]+)['"]\s*(?:,\s*([^)]*))?\)/g, (_, table, args) =>
      args ? `aot_db.${table}.findAll(${args})` : `aot_db.${table}.findAll()`);
    body = body.replace(/sugar\.query/g, "aot_db.query");

    server += `async function ${block.name}(data) {\n`;
    server += `  ${body.split('\n').join('\n  ')}\n`;
    server += `}\n\n`;
  }

  server += `app.get('/__health', (req, res) => res.json({ status: 'ok', engine: 'Codeless v4 AOT' }));\n\n`;

  // 5. Routes (wrapAction: single try/catch, CodelessError normalization)
  server += `// Routes\n`;
  for (const route of ast.routeLines) {
    const method = route.method.toLowerCase();

    let needsAuth = false;
    let schemaToValidate = null;
    let actionName = null;

    for (const step of route.pipeline) {
      if (step.kind === 'auth') needsAuth = true;
      else if (step.kind === 'validate') schemaToValidate = step.schema;
      else if (step.kind === 'action') actionName = step.name;
    }
    if (!actionName) continue;

    server += `app.${method}("${route.path}", wrapAction(async (req, res) => {\n`;

    if (needsAuth) {
      server += `  const rawAuth = req.headers.authorization;\n`;
      server += `  const header = Array.isArray(rawAuth) ? rawAuth[0] : rawAuth;\n`;
      server += `  if (typeof header !== 'string' || !header.startsWith('Bearer ')) throw Object.assign(new Error('Unauthorized'), { status: 401 });\n`;
      server += `  req.user = jwt.verify(header.slice(7), SECRET_KEY, { algorithms: ['HS256'] });\n`;
    }

    if (schemaToValidate) {
      server += `  const validatedBody = validate_${schemaToValidate}(req.body || {});\n`;
      server += `  const ctx = Object.assign(Object.create(null), req.params, validatedBody);\n`;
    } else {
      server += `  const ctx = Object.assign(Object.create(null), req.params, req.query, req.body || {});\n`;
    }

    server += `  const result = await ${actionName}(ctx);\n`;

    if (schemaToValidate) {
      server += `  if (result && typeof result === 'object' && !result.token) {\n`;
      server += `    res.type('json').send(fastJson_${schemaToValidate}(result));\n`;
      server += `  } else {\n`;
      server += `    res.json(result ?? { success: true });\n`;
      server += `  }\n`;
    } else {
      server += `  res.json(result ?? { success: true });\n`;
    }

    server += `}));\n\n`;
  }

  // Global error handler (CodelessError for express.json() and middleware errors)
  server += `app.use((err, req, res, next) => {\n`;
  server += `  if (res.headersSent) return next(err);\n`;
  server += `  const e = toCodelessError(err);\n`;
  server += `  res.status(e.status).json({ error: e.message, message: e.message });\n`;
  server += `});\n\n`;

  server += `const port = parseInt(process.env.PORT || '${DEFAULTS.PORT}', 10);\n`;
  server += `const host = process.env.HOST || '${DEFAULTS.HOST}';\n`;
  server += `const server = app.listen(port, host, () => {\n`;
  server += `  console.log('Codeless v4 server on http://' + host + ':' + port);\n`;
  server += `});\n`;
  server += `server.on('error', (err) => {\n`;
  server += `  if (err.code === 'EADDRINUSE') {\n`;
  server += `    console.error('Port ' + port + ' is already in use. Stop the other process or set PORT to a different number.');\n`;
  server += `    process.exit(1);\n`;
  server += `  }\n`;
  server += `  throw err;\n`;
  server += `});\n`;

  let types = `/**\n * Generated by Codeless v4 AOT\n */\n\n`;
  for (const block of ast.dataBlocks) {
    types += `export interface ${block.name} {\n  id: number;\n`;
    for (const f of block.fields) {
      const t = fieldToTsType(f);
      types += `  ${f.name}${f.optional ? '?' : ''}: ${t};\n`;
    }
    types += `}\n\n`;
  }

  return { server, types };
}
